<?php


use Drupal\Core\StreamWrapper\StreamWrapperManager;
use Drupal\webform\Access\WebformAccessResult;

function sand_webform_webform_submission_access(\Drupal\webform\WebformSubmissionInterface $webform_submission, $operation, \Drupal\Core\Session\AccountInterface $account) {
  if (isset($operation) && $operation === 'view' && is_object($webform_submission)) { 
    // Get all the data on the webform so we can check if a hidden public field exists and is set to true.
    $data = $webform_submission->getData();
    // Get the public query parameter if it exists.
    $public_query_parameter = \Drupal::request()->query->get('public');
    // If the form has a public field and the request has a public query parameter - see if we should allow request.
    if (isset($data['public']) && $data['public'] && !empty($public_query_parameter)) {
      // Get just the URL minus query parameter.
      $request_uri = \Drupal::request()->getPathInfo();
      // @todo I'm assuming that this is a private file, is there a way not to assume that?
      $uri = 'private://' . str_replace('/system/files/','', $request_uri);
      // Now load the file object so we can get the FID.
      $files = \Drupal::entityTypeManager()->getStorage('file')->loadByProperties(['uri' => $uri]);
      /** @var \Drupal\file\FileInterface|null $file */
      $file = reset($files) ?: NULL;
      
      // If no file then just return.
      if (empty($file)) {
        return \Drupal\Core\Access\AccessResult::neutral();
      }
      
      // If the file's FID equals the public query parameter given, allow access, else deny.
      if ($file->id() == $public_query_parameter) {
        return \Drupal\Core\Access\AccessResult::allowed();
      } else {
        return \Drupal\Core\Access\AccessResult::forbidden();
      }
    }
  }
  // This function has no opinion on this access request.
  return \Drupal\Core\Access\AccessResult::neutral();
}

/**
 * Control access to private file downloads and specify HTTP headers.
 *
 * This hook allows modules to enforce permissions on file downloads whenever
 * Drupal is handling file download, as opposed to the web server bypassing
 * Drupal and returning the file from a public directory. Modules can also
 * provide headers to specify information like the file's name or MIME type.
 *
 * @param $uri
 *   The URI of the file.
 *
 * @return string[]|int
 *   If the user does not have permission to access the file, return -1. If the
 *   user has permission, return an array with the appropriate headers. If the
 *   file is not controlled by the current module, the return value should be
 *   NULL.
 *
 * @see \Drupal\system\FileDownloadController::download()
 */
function sand_webform_file_download($uri) {
//    // Do a quick test for low overhead to see if we need to address access status
//    if (str_starts_with($uri, 'private://webform')) {
//       $fid_from_query_paramter = \Drupal::request()->query->get('public');
//        // Check to see if this is a config download.
//        $scheme = StreamWrapperManager::getScheme($uri);
//        $target = StreamWrapperManager::getTarget($uri);
//        $files = \Drupal::entityTypeManager()
//            ->getStorage('file')
//            ->loadByProperties(['uri' => $uri]);
//        /** @var \Drupal\file\FileInterface|null $file */
//        $file = reset($files) ?: NULL;
//        $fid_from_file = $file->id();
//        if (empty($fid_from_query_paramter)) {
//          return null; 
//        } else {
//          if ($fid_from_query_paramter === $fid_from_file) {
//            return []; 
//          } else {
//            return -1; 
//          }
//        }
//    }
}
